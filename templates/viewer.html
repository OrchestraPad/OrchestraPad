<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ song.title }} - Viewer</title>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:red;color:white;z-index:9999;padding:20px;font-size:24px;white-space:pre-wrap;';
            div.innerText = 'JS Error: ' + msg + '\nLine: ' + line + ':' + col + '\n' + url;
            document.body.appendChild(div);
            return false;
        };
    </script>
    <style>
        :root {
            /* Vereinsfarben - Black & Red */
            --md-sys-color-primary: #D32F2F;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #801313;
            --md-sys-color-on-primary-container: #FFDAD9;
            --md-sys-color-surface: #000000;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #25232a;
            --md-sys-color-on-surface-variant: #CAC4D0;
            --md-sys-color-outline: #938F99;
            --md-sys-typescale-h1-font: system-ui, -apple-system, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: var(--md-sys-typescale-h1-font);
            color: var(--md-sys-color-on-surface);
        }

        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
            overflow: auto;
            background: #000;
        }

        canvas {
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            position: absolute;
        }

        #draw-canvas {
            pointer-events: none;
            z-index: 5;
        }

        #pdf-canvas {
            z-index: 1;
        }

        .nav-overlay {
            position: fixed;
            top: 80px;
            bottom: 0;
            width: 15%;
            cursor: pointer;
            z-index: 10;
        }

        .nav-left {
            left: 0;
        }

        .nav-right {
            right: 0;
        }

        /* --- Glassmorphism Toolbar --- */
        .toolbar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 17, 17, 0.85);
            /* Darker for better contrast */
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 10px 20px;
            border-radius: 40px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 100;
            border: 1px solid rgba(255, 0, 0, 0.2);
            /* Red tint border */
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
            min-width: fit-content;
            white-space: nowrap;
        }

        .toolbar.visible {
            display: flex;
        }

        .toolbar-title {
            font-size: 16px;
            font-weight: 500;
            margin: 0 12px;
            color: var(--md-sys-color-on-surface);
        }

        .icon-btn {
            width: 52px;
            /* Larger targets for viewer */
            height: 52px;
            border-radius: 26px;
            border: none;
            background: transparent;
            color: var(--md-sys-color-on-surface-variant);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .icon-btn:active {
            background: rgba(211, 47, 47, 0.3);
            color: var(--md-sys-color-primary);
        }

        .icon-btn.active {
            background: var(--md-sys-color-primary);
            color: white;
        }

        .divider {
            width: 1px;
            height: 32px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 6px;
        }

        select,
        input[type="range"] {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 16px;
        }

        /* --- Touch Feedback --- */
        .touch-feedback {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 25%;
            background: radial-gradient(circle at center, rgba(211, 47, 47, 0.25) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 50;
        }

        .touch-feedback.active {
            opacity: 1;
        }

        .feedback-left {
            left: 0;
        }

        .feedback-right {
            right: 0;
        }

        #ocr-status {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            padding: 20px 40px;
            border-radius: 32px;
            z-index: 1000;
            display: none;
            font-size: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 1px solid var(--md-sys-color-primary);
        }

        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(12px);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--md-sys-color-surface-variant);
            padding: 32px;
            border-radius: 32px;
            max-width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            border: 1px solid #444;
        }

        .page-grid-item {
            padding: 24px;
            border-radius: 16px;
            background: #111;
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            border: 2px solid #333;
            font-size: 18px;
        }

        .page-grid-item.selected {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: var(--md-sys-color-primary);
        }

        .btn-filled {
            background: var(--md-sys-color-primary);
            color: white;
            padding: 16px 32px;
            border-radius: 24px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-size: 16px;
        }

        .btn-filled:active {
            background: var(--md-sys-color-primary-container);
        }
    </style>
    <script src="/static/lib/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = '/static/lib/pdf.worker.min.js';</script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>

<body>
    <!-- SVG Library -->
    <svg style="display: none;">
        <symbol id="icon-home" viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" fill="currentColor" />
        </symbol>
        <symbol id="icon-draw" viewBox="0 0 24 24">
            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="currentColor" />
        </symbol>
        <symbol id="icon-delete" viewBox="0 0 24 24">
            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
                fill="currentColor" />
        </symbol>
        <symbol id="icon-pages" viewBox="0 0 24 24">
            <path
                d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"
                fill="currentColor" />
        </symbol>
        <symbol id="icon-scan" viewBox="0 0 24 24">
            <path d="M12 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm1 13h-2v-6h2v6zm0-8h-2V7h2v2z"
                fill="currentColor" />
        </symbol>
    </svg>

    <div id="ocr-status">
        <div style="font-weight: 500; margin-bottom: 8px;">üîç Analysiere Stimmen...</div>
        <div id="ocr-progress" style="opacity: 0.8;">Seite 1 / ?</div>
    </div>

    <div class="toolbar" id="toolbar">
        <button class="icon-btn" onclick="location.href='/'" title="Bibliothek">
            <svg width="24" height="24">
                <use href="#icon-home" />
            </svg>
        </button>

        <div class="divider"></div>

        <select id="part-select" onchange="changePart()" style="max-width: 140px;">
            <option value="All">Lade...</option>
        </select>

        <div class="divider"></div>

        <input type="range" id="zoom-slider" min="50" max="300" value="100" style="width: 100px;">

        <div class="divider"></div>

        <button class="icon-btn" onclick="toggleDrawingMode()" id="btn-draw" title="Zeichnen">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
            </svg>
        </button>
        <button class="icon-btn" onclick="openOCRModal()" id="btn-ocr" title="Stimmen erkennen">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M15 3V7.5L15 8H19V6H16V5H19V4H16V3H19C20.1 3 21 3.9 21 5V8C21 9.1 20.1 10 19 10H15V13H17V12H19V11H17V10H19C20.1 10 21 10.9 21 12V15C21 16.1 20.1 17 19 17H15V21H11V17H7V21H3V17C1.9 17 1 16.1 1 15V12C1 10.9 1.9 10 3 10H5V8H3C1.9 8 1 7.1 1 6V3H3V4H6V5H3V6H6V8H3V9H5V12H3V13H5V14H3V15H5V16H11V15H13V12H11V11H13V10H11V9H13V8H11V5H15V4H11V3H15M17 14H19V15H17V14M5 4H7V8H5V4M5 11H7V15H5V11M15 11H13.5L15.3 15H16.7L18.5 11H17L16 13.5L15 11Z" />
            </svg>
        </button>
        <button class="icon-btn" onclick="toggleFullscreen()" title="Vollbild">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
            </svg>
        </button>

        <button class="icon-btn" onclick="clearAnnotations()" title="L√∂schen">
            <svg width="24" height="24">
                <use href="#icon-delete" />
            </svg>
        </button>

        <button class="icon-btn" onclick="openPageSelector()" title="Seiten w√§hlen">
            <svg width="24" height="24">
                <use href="#icon-pages" />
            </svg>
        </button>
        </svg>
        </button>

        <div class="divider"></div>

        <div class="toolbar-title" id="page-indicator">
            <span id="page_num">1</span> / <span id="page_count">1</span>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="pdf-canvas"></canvas>
        <canvas id="draw-canvas"></canvas>

        <div class="nav-overlay nav-left" onclick="handleTap('prev')" id="nav-left"></div>
        <div class="nav-overlay nav-right" onclick="handleTap('next')" id="nav-right"></div>

        <div id="feedback-left" class="touch-feedback feedback-left"></div>
        <div id="feedback-right" class="touch-feedback feedback-right"></div>
    </div>

    <!-- Page Selection Modal -->
    <div id="page-selector-modal" class="modal">
        <div class="modal-content">
            <h2 style="margin-top: 0;">Seiten ausw√§hlen</h2>
            <div style="margin-bottom: 24px; display: flex; gap: 12px;">
                <button onclick="setSelectedAll(false)" class="btn-filled"
                    style="background: var(--md-sys-color-surface-variant); color: var(--md-sys-color-on-surface-variant);">Alles
                    abw√§hlen</button>
                <button onclick="setSelectedAll(true)" class="btn-filled"
                    style="background: var(--md-sys-color-surface-variant); color: var(--md-sys-color-on-surface-variant);">Alles
                    ausw√§hlen</button>
            </div>
            <div id="page-grid"
                style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; overflow-y: auto; padding: 4px;">
                <!-- Grid items generated by JS -->
            </div>
            <div style="margin-top: 32px; display: flex; justify-content: flex-end; gap: 12px;">
                <button onclick="closePageSelector()" class="btn-filled"
                    style="background: transparent; color: var(--md-sys-color-primary);">Abbrechen</button>
                <button onclick="applyPageSelection()" class="btn-filled">Anwenden</button>
            </div>
        </div>
    </div>

    <!-- Page Selection Modal -->
    <div id="page-selector-modal"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 100; flex-direction: column; align-items: center; justify-content: center;">
        <h2 style="color: white; margin-bottom: 20px;">Seiten ausw√§hlen</h2>
        <div style="margin-bottom: 20px; display: flex; gap: 10px;">
            <button onclick="setSelectedAll(false)"
                style="padding: 10px 20px; font-size: 16px; background: #555; color: white; border: 1px solid #777; border-radius: 5px; cursor: pointer;">Alles
                abw√§hlen</button>
            <button onclick="setSelectedAll(true)"
                style="padding: 10px 20px; font-size: 16px; background: #555; color: white; border: 1px solid #777; border-radius: 5px; cursor: pointer;">Alles
                ausw√§hlen</button>
        </div>
        <div id="page-grid"
            style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-height: 70vh; overflow-y: auto; padding: 20px;">
            <!-- Grid items generated by JS -->
        </div>
        <div style="margin-top: 20px; display: flex; gap: 20px;">
            <button onclick="applyPageSelection()"
                style="padding: 15px 30px; font-size: 20px; background: #4CAF50; color: white; border: none; border-radius: 5px;">Anwenden</button>
            <button onclick="closePageSelector()"
                style="padding: 15px 30px; font-size: 20px; background: #f44336; color: white; border: none; border-radius: 5px;">Abbrechen</button>
        </div>
    </div>

    <!-- OCR Selection Overlay -->
    <div id="ocr-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; cursor: crosshair;">
        <div id="ocr-box"
            style="display: none; position: absolute; border: 2px solid red; background: rgba(255, 0, 0, 0.2); pointer-events: none;">
        </div>
        <div
            style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 20px; color: white; pointer-events: auto;">
            <span>Bereich markieren (Stimme/Instrument)</span>
            <button onclick="closeOCRMode()"
                style="margin-left: 15px; padding: 5px 10px; background: #666; border: none; color: white; border-radius: 5px; cursor: pointer;">Abbrechen</button>
            <button onclick="testOCR()"
                style="margin-left: 10px; padding: 5px 10px; background: #2196F3; border: none; color: white; border-radius: 5px; cursor: pointer;">Testen</button>
            <button onclick="scanAllPages()"
                style="margin-left: 10px; padding: 5px 10px; background: #4CAF50; border: none; color: white; border-radius: 5px; cursor: pointer;">Alle
                Seiten scannen</button>
        </div>
    </div>

    <!-- OCR Results Modal -->
    <div id="ocr-results-modal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2100; align-items: center; justify-content: center;">
        <div
            style="background: #25232a; padding: 24px; border-radius: 16px; width: 80%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <h2 style="margin-top: 0; color: #E6E1E5;">Erkannte Stimmen</h2>
            <div id="ocr-results-list"
                style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
                <!-- Results go here -->
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="document.getElementById('ocr-results-modal').style.display='none'"
                    style="padding: 10px 20px; background: transparent; color: #D32F2F; border: 1px solid #D32F2F; border-radius: 20px; cursor: pointer;">Abbrechen</button>
                <button onclick="saveOCRResults()"
                    style="padding: 10px 20px; background: #D32F2F; color: white; border: none; border-radius: 20px; cursor: pointer;">Speichern</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; align-items: center; justify-content: center; flex-direction: column; color: white;">
        <div class="spinner"
            style="border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;">
        </div>
        <div style="margin-top: 20px; font-size: 18px;">Verarbeite...</div>
        <style>
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </div>

    <script>
        let isDrawingMode = false; // Added this line
        const songId = {{ song.id }}; // Global ID
        const url = '/pdf/{{ song.file_path }}';
        const songKey = 'song_settings_{{ song.id }}';
        const padding = 20; // 0.5cm approx padding

        let pdfDoc = null,
            pdfCanvas = document.getElementById('pdf-canvas'),
            ctx = pdfCanvas.getContext('2d'),
            drawCanvas = document.getElementById('draw-canvas'),
            drawCtx = drawCanvas.getContext('2d');

        // State
        let currentZoom = 100;
        let isDrawing = false;

        let pageRendering = false;
        let pageNumPending = null;

        // Data
        let availableParts = {};
        let pageOrientations = {}; // { pageNum: 'landscape'|'portrait' }

        // Navigation State
        // "Virtual Pages" are what the user sees. 
        // A single PDF page (Landscape) might be 2 Virtual Pages (Left, Right).
        let virtualPages = []; // [ { pdfPage: 1, side: 'left' }, { pdfPage: 1, side: 'right' }, { pdfPage: 2, side: 'full' } ]
        let currentVirtualIndex = 0; // 0-based index into virtualPages

        // Filter Settings
        let currentPart = 'All';
        let manualPages = []; // Array of PDF page nums
        let cachedBboxes = {}; // { virtualPageIndex: {x,y,w,h} }

        // --- Init ---
        async function loadSongData() {
            try {
                // 1. Fetch settings and cached bboxes
                const resp = await fetch(`/song_settings/{{ song.id }}`);
                const data = await resp.json();

                if (data.settings) {
                    if (data.settings.zoom) {
                        currentZoom = data.settings.zoom;
                        document.getElementById('zoom-slider').value = currentZoom;
                    }
                    if (data.settings.manualPages) manualPages = data.settings.manualPages;
                    if (data.settings.part) currentPart = data.settings.part;
                }

                if (data.bounding_boxes) {
                    cachedBboxes = data.bounding_boxes;
                }

                // 2. Load PDF
                const pdfDoc_ = await pdfjsLib.getDocument(url).promise;
                pdfDoc = pdfDoc_;

                // 3. Detect Orientations
                await detectPageOrientations();

                // 4. Load Parts
                await loadParts();

                // 5. Initial Render
                renderPage(currentVirtualIndex);

            } catch (err) {
                console.error("Error loading song data:", err);
                // Fallback to local storage if server fails? 
                const saved = JSON.parse(localStorage.getItem(songKey) || '{}');
                if (saved.zoom) currentZoom = saved.zoom;
                // ...
            }
        }

        loadSongData();

        async function detectPageOrientations() {
            // We just need the viewport of each page to check ratio
            const promises = [];
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                promises.push(pdfDoc.getPage(i).then(page => {
                    const view = page.getViewport({ scale: 1 });
                    // If Width > Height * 1.3 (tolerance), assume Double Page Landscape
                    if (view.width > view.height * 1.2) {
                        pageOrientations[i] = 'landscape';
                    } else {
                        pageOrientations[i] = 'portrait';
                    }
                }));
            }
            await Promise.all(promises);
        }

        // --- OCR Logic ---
        async function startOcr() {
            if (!confirm("Soll die Stimmenerkennung (OCR) f√ºr alle Seiten gestartet werden? Das kann einen Moment dauern.")) return;

            const statusDiv = document.getElementById('ocr-status');
            const progressSpan = document.getElementById('ocr-progress');
            const btn = document.getElementById('ocr-btn');

            statusDiv.style.display = 'block';
            btn.disabled = true;
            btn.innerText = '‚åõ Scanne...';

            const pageTexts = {};
            const worker = await Tesseract.createWorker('deu+eng'); // Load German and English

            try {
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    progressSpan.innerText = `Seite ${i} / ${pdfDoc.numPages}`;

                    const page = await pdfDoc.getPage(i);
                    // Render only top 25% of page for OCR (usually where headers are)
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');

                    // We only want the top part
                    const h = viewport.height * 0.25;
                    canvas.width = viewport.width;
                    canvas.height = h;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport,
                        transform: [1, 0, 0, 1, 0, 0] // No offset needed if we just let it draw and crop later? 
                        // Actually, better to use the transform to only draw the top.
                    }).promise;

                    const { data: { text } } = await worker.recognize(canvas);
                    pageTexts[`page_${i}`] = text;
                    console.log(`Text Page ${i}:`, text);
                }

                // Now send to backend for regex analysis
                const response = await fetch(`/run_ocr_analysis/{{ song.id }}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pageTexts)
                });

                const result = await response.json();
                if (result.status === 'success') {
                    alert("Erkennung abgeschlossen! Stimmen wurden aktualisiert.");
                    location.reload(); // Reload to refresh the part list
                } else {
                    alert("Fehler bei der Analyse: " + result.error);
                }

            } catch (err) {
                console.error(err);
                alert("OCR Fehlgeschlagen: " + err.message);
            } finally {
                await worker.terminate();
                statusDiv.style.display = 'none';
                btn.disabled = false;
                btn.innerText = 'üîç Stimm-Scan';
            }
        }

        function calculateVirtualPages() {
            // 1. Determine which PDF pages are "active" based on filters
            let activePdfPages = [];
            if (manualPages.length > 0) {
                activePdfPages = manualPages.sort((a, b) => a - b);
                // Also ensure Part Select is capable of showing this state
            } else if (currentPart !== 'All' && availableParts[currentPart]) {
                activePdfPages = availableParts[currentPart];
            } else {
                activePdfPages = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
            }

            // 2. Build Virtual Pages based on Orientation
            virtualPages = [];
            activePdfPages.forEach(pNum => {
                if (pageOrientations[pNum] === 'landscape') {
                    // Split
                    virtualPages.push({ pdfPage: pNum, side: 'left' });
                    virtualPages.push({ pdfPage: pNum, side: 'right' });
                } else {
                    virtualPages.push({ pdfPage: pNum, side: 'full' });
                }
            });

            // Update Page Count UI
            updatePageCounter();
        }

        async function renderPage(vIndex) {
            if (vIndex < 0 || vIndex >= virtualPages.length) return;
            currentVirtualIndex = vIndex;

            pageRendering = true;
            const vPage = virtualPages[vIndex];
            const page = await pdfDoc.getPage(vPage.pdfPage);

            // --- Logic for Split Rendering ---

            // Container Dims
            const container = document.getElementById('canvas-container');
            const cw = container.clientWidth;
            const ch = container.clientHeight;

            // 1. Render to Offscreen Canvas for Auto-Crop Analysis
            // We need to render the *relevant part* of the page.

            const baseViewport = page.getViewport({ scale: 0.5 }); // Low res for speed detection

            let bbox;
            if (cachedBboxes[vIndex]) {
                bbox = cachedBboxes[vIndex];
            } else {
                // Calculate effective width of the sub-page
                let scanWidth = baseViewport.width;
                let scanHeight = baseViewport.height;
                let scanOffsetX = 0;

                if (vPage.side === 'left') {
                    scanWidth = baseViewport.width / 2;
                } else if (vPage.side === 'right') {
                    scanWidth = baseViewport.width / 2;
                    scanOffsetX = - (baseViewport.width / 2);
                }

                const offCanvas = document.createElement('canvas');
                offCanvas.width = scanWidth;
                offCanvas.height = scanHeight;
                const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });

                offCtx.translate(scanOffsetX, 0);
                await page.render({ canvasContext: offCtx, viewport: baseViewport }).promise;

                bbox = getContentBoundingBox(offCtx, offCanvas.width, offCanvas.height);

                // Save to cache and server
                cachedBboxes[vIndex] = bbox;
                saveSettingsToServer();

                // Restore context for sanity (though we discard it)
                offCtx.setTransform(1, 0, 0, 1, 0, 0);
            }

            // bbox is in 0.5 scale relative to the *split* page.
            const contentW = (bbox.w / 0.5);
            const contentH = (bbox.h / 0.5);

            // 3. Calculate Final Scale to fit Container
            const scaleW = (cw - (padding * 2)) / contentW;
            const scaleH = (ch - (padding * 2)) / contentH;
            const baseScale = Math.min(scaleW, scaleH);
            const finalScale = baseScale * (currentZoom / 100);

            // 4. Calculate Final Offsets for Centering
            const visibleW = contentW * finalScale;
            const visibleH = contentH * finalScale;
            const screenOffsetX = (cw - visibleW) / 2;
            const screenOffsetY = (ch - visibleH) / 2;

            // 5. Calculate Render Transforms
            // We want the TOP-LEFT of the content (bbox.x, bbox.y in split-coords) to be at (screenOffsetX, screenOffsetY).
            // Canvas needs to hold the 'visible' part.
            // But we render the *page* which is huge.
            // Strategy: Move the canvas element so the desired box is centered.

            // Effectively:
            // Canvas Left = screenOffsetX - (bbox.x/0.5 * finalScale)
            // Canvas Top = screenOffsetY - (bbox.y/0.5 * finalScale)

            // BUT: If it's a 'right' side, the text starts at 0 relative to the split.
            // But relative to the WHOLE page, it starts at (OriginalWidth/2).
            // We are drawing the WHOLE page onto the canvas, but clipping it via canvas size?
            // No, PDF.js renders whole page.

            // Better: We render the split view exactly like the scan view, but at high res.
            // Setup final canvas to be size of the viewport (or larger if we want to just move it).
            // Actually, simplest is:
            // Render the WHOLE page on a big canvas, then position it so the relevant part (Right Half -> BBox) is visible?
            // This is wasteful for memory.

            // Optimization: Use the same trick as scan.
            // Canvas size = Split size (approx).
            // Context translate (-Offset).

            const highResViewport = page.getViewport({ scale: finalScale });

            let finalCanvasWidth = highResViewport.width;
            let finalCanvasHeight = highResViewport.height;
            let finalDrawOffsetX = 0;

            if (vPage.side === 'left') {
                finalCanvasWidth = highResViewport.width / 2;
            } else if (vPage.side === 'right') {
                finalCanvasWidth = highResViewport.width / 2;
                finalDrawOffsetX = - (highResViewport.width / 2);
            }

            // Set Canvas to the size of the *View* (roughly)
            // Actually, we want canvas size = visibleW, visibleH to exclude whitespace?
            // Or just keep it simpe: Canvas = Half Page Size. Position = Center.
            // Let's stick to the previous positioning logic which moves the canvas div.
            // But now the 'Canvas' content is different (Half Page).

            // Re-calculate positioning based on the *Rendered Half Canvas*.
            // BBox (x,y) is relative to the Half Canvas (0,0).
            const canvasLeft = screenOffsetX - ((bbox.x / 0.5) * finalScale);
            const canvasTop = screenOffsetY - ((bbox.y / 0.5) * finalScale);

            // Resize Canvas to fit the HALF page (scaled)
            pdfCanvas.width = finalCanvasWidth;
            pdfCanvas.height = finalCanvasHeight;
            drawCanvas.width = finalCanvasWidth;
            drawCanvas.height = finalCanvasHeight;

            // Render
            ctx.save();
            ctx.translate(finalDrawOffsetX, 0);
            await page.render({ canvasContext: ctx, viewport: highResViewport }).promise;
            ctx.restore();

            // Position Canvas
            pdfCanvas.style.left = canvasLeft + 'px';
            pdfCanvas.style.top = canvasTop + 'px';
            drawCanvas.style.left = canvasLeft + 'px';
            drawCanvas.style.top = canvasTop + 'px';

            // Draw Annotations (Need adjustment for split?)
            // Annotations are currently global per PDF page.
            // If I draw on Right side, x coord is 0..Width.
            // But stored annotation is 0..FullWidth?
            // For simplicity: We enable drawing on the visible canvas. 
            // Save logic: Store 'song_{id}_page_{pdfPage}_{side}'.
            // This treats Left/Right as separate annotation surfaces. Correct and simple.

            loadAnnotations(vPage.pdfPage, vPage.side);

            pageRendering = false;
            updatePageCounter();

            if (pageNumPending !== null) {
                renderPage(pageNumPending);
                pageNumPending = null;
            }
        }

        // --- Utils ---
        function getContentBoundingBox(ctx, w, h) {
            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            let minX = w, minY = h, maxX = 0, maxY = 0;
            const threshold = 250;

            for (let y = 0; y < h; y += 5) {
                for (let x = 0; x < w; x += 5) {
                    const i = (y * w + x) * 4;
                    if (data[i] < threshold || data[i + 1] < threshold || data[i + 2] < threshold) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            if (maxX < minX) return { x: 0, y: 0, w: w, h: h };
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        }

        function queueRenderPage(vIndex) {
            if (pageRendering) {
                pageNumPending = vIndex;
            } else {
                renderPage(vIndex);
            }
        }

        function updatePageCounter() {
            document.getElementById('page_num').textContent = currentVirtualIndex + 1;
            document.getElementById('page_count').textContent = virtualPages.length;
        }

        // --- Navigation ---
        function prevPage() {
            if (currentVirtualIndex <= 0) return;
            queueRenderPage(currentVirtualIndex - 1);
        }

        function nextPage() {
            if (currentVirtualIndex >= virtualPages.length - 1) return;
            queueRenderPage(currentVirtualIndex + 1);
        }

        // --- Parts & Manual Filter ---
        function loadParts() {
            return fetch('/analyze_parts/{{ song.id }}')
                .then(r => r.json())
                .then(data => {
                    availableParts = data;
                    const select = document.getElementById('part-select');
                    select.innerHTML = '<option value="All">Alle Stimmen</option>';

                    let hasCurrent = false;
                    for (const [name, pages] of Object.entries(availableParts)) {
                        const opt = document.createElement('option');
                        opt.value = name;
                        opt.textContent = name + ' (' + pages.length + ' S.)';
                        select.appendChild(opt);
                        if (name === currentPart) hasCurrent = true;
                    }

                    if (manualPages.length > 0) {
                        const opt = document.createElement('option');
                        opt.value = "Manual";
                        opt.textContent = "Benutzerdefiniert";
                        select.appendChild(opt);
                        select.value = "Manual";
                    } else if (hasCurrent) {
                        select.value = currentPart;
                    } else {
                        currentPart = 'All';
                    }

                    calculateVirtualPages();
                });
        }

        function changePart() {
            const val = document.getElementById('part-select').value;
            if (val === 'Manual') {
                // Keep manual
            } else {
                currentPart = val;
                manualPages = [];
                saveSettingsToServer();
            }
            calculateVirtualPages();
            currentVirtualIndex = 0; // Reset to start
            renderPage(0);
        }

        function applyPageSelection() {
            // ... (Same UI logic for gathering selected pages)
            const grid = document.getElementById('page-grid');
            const selected = [];
            grid.childNodes.forEach(node => {
                if (node.dataset.selected === 'true') {
                    selected.push(parseInt(node.dataset.pageNum));
                }
            });
            manualPages = selected.sort((a, b) => a - b);
            saveSettingsToServer();

            document.getElementById('part-select').value = 'Manual';

            calculateVirtualPages();
            currentVirtualIndex = 0;
            renderPage(0);
            closePageSelector();
        }

        function openPageSelector() {
            const modal = document.getElementById('page-selector-modal');
            const grid = document.getElementById('page-grid');
            grid.innerHTML = '';

            let currentlySelected = manualPages.length > 0 ? manualPages : Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const div = document.createElement('div');
                div.className = 'page-grid-item' + (currentlySelected.includes(i) ? ' selected' : '');
                div.textContent = i;
                div.dataset.pageNum = i;

                const isLand = pageOrientations[i] === 'landscape';
                if (isLand) {
                    div.innerHTML += '<br><small style="font-size:10px; opacity:0.7">Landscape</small>';
                }

                div.dataset.selected = currentlySelected.includes(i);

                div.onclick = function () {
                    const isSel = div.dataset.selected === 'true';
                    div.dataset.selected = !isSel;
                    if (!isSel) div.classList.add('selected');
                    else div.classList.remove('selected');
                };
                grid.appendChild(div);
            }
            modal.style.display = 'flex';
        }

        function setSelectedAll(selected) {
            const grid = document.getElementById('page-grid');
            grid.childNodes.forEach(div => {
                div.dataset.selected = selected;
                if (selected) div.classList.add('selected');
                else div.classList.remove('selected');
            });
        }

        function closePageSelector() { document.getElementById('page-selector-modal').style.display = 'none'; }

        // --- Common Listeners ---
        document.getElementById('zoom-slider').addEventListener('input', (e) => {
            currentZoom = e.target.value;
            // Debounce save? For zoom maybe local is enough, but user wants persistence
            saveSettingsToServer();
            renderPage(currentVirtualIndex);
        });

        // --- Drawing & Annotations ---
        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('btn-draw');
            const navLeft = document.getElementById('nav-left');
            const navRight = document.getElementById('nav-right');

            if (isDrawingMode) {
                if (btn) btn.classList.add('active');
                drawCanvas.style.pointerEvents = 'auto';
                if (navLeft) navLeft.style.display = 'none';
                if (navRight) navRight.style.display = 'none';
            } else {
                if (btn) btn.classList.remove('active');
                drawCanvas.style.pointerEvents = 'none';
                if (navLeft) navLeft.style.display = 'block';
                if (navRight) navRight.style.display = 'block';
                // Save on exit
                const vPage = virtualPages[currentVirtualIndex];
                const storageKey = songKey + '_page_' + vPage.pdfPage + '_' + vPage.side;
                localStorage.setItem(storageKey, drawCanvas.toDataURL());
            }
        }

        function loadAnnotations(page, side) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            const storageKey = songKey + '_page_' + page + '_' + side;
            const data = localStorage.getItem(storageKey);
            if (data) {
                const img = new Image();
                img.onload = function () { drawCtx.drawImage(img, 0, 0); };
                img.src = data;
            }
        }

        function clearAnnotations() {
            if (confirm("Alle Zeichnungen auf dieser Seite l√∂schen?")) {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                const vPage = virtualPages[currentVirtualIndex];
                const storageKey = songKey + '_page_' + vPage.pdfPage + '_' + vPage.side;
                localStorage.removeItem(storageKey);
            }
        }

        function handleTap(action) {
            if (isDrawingMode) return;
            if (action === 'prev') { prevPage(); }
            else if (action === 'next') { nextPage(); }
        }

        function saveSettingsToServer() {
            const data = {
                settings: {
                    zoom: currentZoom,
                    manualPages: manualPages,
                    part: currentPart
                },
                bounding_boxes: cachedBboxes
            };

            fetch(`/song_settings/{{ song.id }}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            // Still save to localStorage as fallback
            localStorage.setItem(songKey, JSON.stringify(data.settings));
        }

        // ... (Drawing toggle and events essentially same, just need saveAnnotations update) 

        function toggleDrawMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('draw-mode-btn');
            const navLeft = document.getElementById('nav-left');
            const navRight = document.getElementById('nav-right');
            if (isDrawingMode) {
                btn.classList.add('active');
                drawCanvas.style.pointerEvents = 'auto';
                navLeft.style.display = 'none'; navRight.style.display = 'none';
            } else {
                btn.classList.remove('active');
                drawCanvas.style.pointerEvents = 'none';
                navLeft.style.display = 'block'; navRight.style.display = 'block';
            }
        }

        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseout', stopDrawing);
        drawCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousedown", { clientX: touch.clientX, clientY: touch.clientY });
            drawCanvas.dispatchEvent(mouseEvent);
        });
        drawCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousemove", { clientX: touch.clientX, clientY: touch.clientY });
            drawCanvas.dispatchEvent(mouseEvent);
        });
        drawCanvas.addEventListener('touchend', (e) => { drawCanvas.dispatchEvent(new MouseEvent("mouseup", {})); });

        function startDrawing(e) { if (isDrawingMode) { isDrawing = true; draw(e); } }
        function draw(e) {
            if (!isDrawing || !isDrawingMode) return;
            const rect = drawCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left);
            const y = (e.clientY - rect.top);
            drawCtx.lineWidth = 3; drawCtx.lineCap = 'round'; drawCtx.strokeStyle = 'red';
            drawCtx.lineTo(x, y); drawCtx.stroke(); drawCtx.beginPath(); drawCtx.moveTo(x, y);
        }
        // Updated Storage keys for Side
        function stopDrawing() {
            if (!isDrawing) return; isDrawing = false; drawCtx.beginPath();
            const vPage = virtualPages[currentVirtualIndex];
            saveAnnotations(vPage.pdfPage, vPage.side);
        }

        function saveAnnotations(page, side) {
            const data = drawCanvas.toDataURL();
            const storageKey = songKey + '_page_' + page + '_' + side;
            localStorage.setItem(storageKey, data);
        }

        function loadAnnotations(page, side) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            const storageKey = songKey + '_page_' + page + '_' + side;
            const data = localStorage.getItem(storageKey);
            if (data) {
                const img = new Image();
                img.onload = function () { drawCtx.drawImage(img, 0, 0); };
                img.src = data;
            }
        }

        function clearAnnotations() {
            if (confirm("Alle Zeichnungen auf dieser Seite l√∂schen?")) {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                const vPage = virtualPages[currentVirtualIndex];
                const storageKey = songKey + '_page_' + vPage.pdfPage + '_' + vPage.side;
                localStorage.removeItem(storageKey);
            }
        }

        function handleTap(action) {
            if (isDrawingMode) return;
            if (action === 'prev') { triggerFeedback('left'); prevPage(); }
            else if (action === 'next') { triggerFeedback('right'); nextPage(); }
        }
        function triggerFeedback(side) {
            const el = document.getElementById('feedback-' + side);
            el.classList.add('active'); setTimeout(() => el.classList.remove('active'), 200);
        }
        // OCR Logic
        let ocrStartX, ocrStartY, ocrBox = { x: 0, y: 0, w: 0, h: 0 };
        const ocrOverlay = document.getElementById('ocr-overlay');
        const ocrBoxDiv = document.getElementById('ocr-box');

        function openOCRModal() {
            ocrOverlay.style.display = 'block';
            // Reset box
            ocrBoxDiv.style.display = 'none';
            ocrBox = { x: 0, y: 0, w: 0, h: 0 };
        }

        function closeOCRMode() {
            ocrOverlay.style.display = 'none';
        }

        // Mouse events for OCR drawing
        ocrOverlay.onmousedown = function (e) {
            if (e.target.tagName === 'BUTTON') return;
            ocrStartX = e.clientX;
            ocrStartY = e.clientY;
            ocrBoxDiv.style.display = 'block';
            ocrBoxDiv.style.left = ocrStartX + 'px';
            ocrBoxDiv.style.top = ocrStartY + 'px';
            ocrBoxDiv.style.width = '0px';
            ocrBoxDiv.style.height = '0px';

            ocrOverlay.onmousemove = function (e) {
                let w = e.clientX - ocrStartX;
                let h = e.clientY - ocrStartY;
                ocrBoxDiv.style.width = Math.abs(w) + 'px';
                ocrBoxDiv.style.height = Math.abs(h) + 'px';
                ocrBoxDiv.style.left = (w < 0 ? e.clientX : ocrStartX) + 'px';
                ocrBoxDiv.style.top = (h < 0 ? e.clientY : ocrStartY) + 'px';
            };

            ocrOverlay.onmouseup = function (e) {
                ocrOverlay.onmousemove = null;
                ocrOverlay.onmouseup = null;
                // Calculate percentage relative to canvas
                const canvas = document.querySelector('canvas'); // The main PDF canvas
                const rect = canvas.getBoundingClientRect();

                // Get box rect
                const boxRect = ocrBoxDiv.getBoundingClientRect();

                // Calculate relative to PDF canvas
                ocrBox = {
                    x: ((boxRect.left - rect.left) / rect.width) * 100,
                    y: ((boxRect.top - rect.top) / rect.height) * 100,
                    w: (boxRect.width / rect.width) * 100,
                    h: (boxRect.height / rect.height) * 100
                };
                console.log("OCR Box:", ocrBox);
            };
        };

        // Also support touch
        ocrOverlay.ontouchstart = function (e) {
            if (e.target.tagName === 'BUTTON') return;
            const touch = e.touches[0];
            ocrStartX = touch.clientX;
            ocrStartY = touch.clientY;
            ocrBoxDiv.style.display = 'block';

            ocrOverlay.ontouchmove = function (e) {
                e.preventDefault();
                const touch = e.touches[0];
                let w = touch.clientX - ocrStartX;
                let h = touch.clientY - ocrStartY;
                ocrBoxDiv.style.width = Math.abs(w) + 'px';
                ocrBoxDiv.style.height = Math.abs(h) + 'px';
                ocrBoxDiv.style.left = (w < 0 ? touch.clientX : ocrStartX) + 'px';
                ocrBoxDiv.style.top = (h < 0 ? touch.clientY : ocrStartY) + 'px';
            };

            ocrOverlay.ontouchend = function (e) {
                ocrOverlay.ontouchmove = null;
                // Recalc logic same as mouse...
                const canvas = document.querySelector('canvas');
                const rect = canvas.getBoundingClientRect();
                const boxRect = ocrBoxDiv.getBoundingClientRect();

                ocrBox = {
                    x: ((boxRect.left - rect.left) / rect.width) * 100,
                    y: ((boxRect.top - rect.top) / rect.height) * 100,
                    w: (boxRect.width / rect.width) * 100,
                    h: (boxRect.height / rect.height) * 100
                };
            };
        };

        function testOCR() {
            if (ocrBox.w === 0) { alert("Bitte erst einen Bereich markieren!"); return; }

            fetch('/scan_part_region', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    song_id: songId,
                    page: virtualPages[currentVirtualIndex].pdfPage,
                    box: ocrBox
                })
            })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        alert("Erkannt: " + data.text);
                    } else {
                        alert("Fehler: " + data.message);
                    }
                });
        }

        function scanAllPages() {
            if (ocrBox.w === 0) { alert("Bitte erst einen Bereich markieren!"); return; }

            document.getElementById('loading-overlay').style.display = 'flex';

            fetch('/scan_all_pages_region', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    song_id: songId,
                    box: ocrBox
                })
            })
                .then(r => r.json())
                .then(data => {
                    document.getElementById('loading-overlay').style.display = 'none';
                    if (data.status === 'success') {
                        showOCRResults(data.results);
                    } else {
                        alert("Fehler: " + data.message);
                    }
                });
        }

        function showOCRResults(results) {
            const listDiv = document.getElementById('ocr-results-list');
            listDiv.innerHTML = '';

            for (const [page, text] of Object.entries(results)) {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '10px';
                row.innerHTML = `
                    <span style="width: 60px;">Seite ${page}:</span>
                    <input type="text" value="${text}" class="input-pill" style="flex: 1;">
                `;
                listDiv.appendChild(row);
            }

            document.getElementById('ocr-results-modal').style.display = 'flex';
        }

        function saveOCRResults() {
            // Collect data from inputs
            const inputs = document.querySelectorAll('#ocr-results-list input');
            const mapping = {};

            inputs.forEach((input, index) => {
                const text = input.value.trim();
                if (text) {
                    if (!mapping[text]) mapping[text] = [];
                    mapping[text].push(index + 1); // 1-based page index
                }
            });

            fetch('/save_part_mapping', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    song_id: songId,
                    parts: mapping
                })
            })
                .then(r => r.json())
                .then(() => {
                    document.getElementById('ocr-results-modal').style.display = 'none';
                    closeOCRMode();
                    alert("Stimmen gespeichert!");
                    location.reload();
                });
        }
        document.addEventListener('keydown', (e) => {
            if (isDrawingMode) return;
            if (['ArrowRight', 'Space', 'Enter', 'PageDown'].includes(e.key) || e.code == 'Space') { triggerFeedback('right'); nextPage(); }
            else if (['ArrowLeft', 'Backspace', 'PageUp'].includes(e.key)) { triggerFeedback('left'); prevPage(); }
        });
        document.getElementById('canvas-container').addEventListener('click', (e) => {
            if (isDrawingMode) return;
            if (e.target.id === 'canvas-container' || e.target.id === 'pdf-canvas') {
                document.getElementById('toolbar').classList.toggle('visible');
            }
        });
    </script>
</body>

</html>