<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ song.title }} - Viewer</title>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:red;color:white;z-index:9999;padding:20px;font-size:24px;white-space:pre-wrap;';
            div.innerText = 'JS Error: ' + msg + '\nLine: ' + line + ':' + col + '\n' + url;
            document.body.appendChild(div);
            return false;
        };
    </script>
    <style>
        :root {
            --md-sys-color-primary: #D32F2F;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #801313;
            --md-sys-color-on-primary-container: #FFDAD9;
            --md-sys-color-surface: #000000;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #25232a;
            --md-sys-color-on-surface-variant: #CAC4D0;
            --md-sys-color-outline: #938F99;
            --md-sys-typescale-h1-font: system-ui, -apple-system, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: var(--md-sys-typescale-h1-font);
            color: var(--md-sys-color-on-surface);
        }

        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
            overflow: auto;
            background: #000;
        }

        canvas {
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            position: absolute;
        }

        #draw-canvas {
            pointer-events: none;
            z-index: 5;
        }

        #pdf-canvas {
            z-index: 1;
        }

        .nav-overlay {
            position: fixed;
            top: 80px;
            bottom: 0;
            width: 15%;
            cursor: pointer;
            z-index: 10;
        }

        .nav-left {
            left: 0;
        }

        .nav-right {
            right: 0;
        }

        .toolbar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 17, 17, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 10px 20px;
            border-radius: 40px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 100;
            border: 1px solid rgba(255, 0, 0, 0.2);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
            min-width: fit-content;
            white-space: nowrap;
        }

        .toolbar.visible {
            display: flex;
        }

        .toolbar-title {
            font-size: 16px;
            font-weight: 500;
            margin: 0 12px;
            color: var(--md-sys-color-on-surface);
        }

        .icon-btn {
            width: 52px;
            height: 52px;
            border-radius: 26px;
            border: none;
            background: transparent;
            color: var(--md-sys-color-on-surface-variant);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .icon-btn:active {
            background: rgba(211, 47, 47, 0.3);
            color: var(--md-sys-color-primary);
        }

        .icon-btn.active {
            background: var(--md-sys-color-primary);
            color: white;
        }

        .divider {
            width: 1px;
            height: 32px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 6px;
        }

        select,
        input[type="range"] {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 16px;
        }

        /* Ensure options are readable on all browsers */
        option {
            background-color: #25232a;
            color: white;
        }

        .touch-feedback {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 25%;
            background: radial-gradient(circle at center, rgba(211, 47, 47, 0.25) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 50;
        }

        .touch-feedback.active {
            opacity: 1;
        }

        .feedback-left {
            left: 0;
        }

        .feedback-right {
            right: 0;
        }

        #ocr-status {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            padding: 20px 40px;
            border-radius: 32px;
            z-index: 1000;
            display: none;
            font-size: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 1px solid var(--md-sys-color-primary);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(12px);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--md-sys-color-surface-variant);
            padding: 32px;
            border-radius: 32px;
            width: 90%;
            max-width: 600px;
            height: 80vh;
            /* Fixed height for consistent scrolling container */
            display: flex;
            flex-direction: column;
            border: 1px solid #444;
            position: relative;
            /* Ensure stacking context */
        }

        .page-grid-item {
            padding: 8px;
            border-radius: 12px;
            background: #111;
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
            /* Spacing between items in list mode */
            min-height: 150px;
            /* Prevent squashing */
            flex-shrink: 0;
            /* Prevent shrinking in flex container */
            user-select: none;
            /* Prevent text selection on touch */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .page-thumb {
            width: 100%;
            height: auto;
            /* Approx A4 */
            object-fit: contain;
            border-radius: 4px;
            background: #fff;
            /* White background for scans */
            pointer-events: none;
            /* Let touches pass through to the container (div) for scrolling */
            user-select: none;
            -webkit-user-drag: none;
        }

        .page-number-badge {
            position: absolute;
            bottom: 4px;
            /* Move to bottom */
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        .page-grid-item.selected {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-color: var(--md-sys-color-primary);
        }

        .btn-filled {
            background: var(--md-sys-color-primary);
            color: white;
            padding: 16px 32px;
            border-radius: 24px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-size: 16px;
        }

        .btn-filled:active {
            background: var(--md-sys-color-primary-container);
        }
    </style>
    <script src="/static/lib/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = '/static/lib/pdf.worker.min.js';</script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>

<body>
    <svg style="display: none;">
        <symbol id="icon-home" viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" fill="currentColor" />
        </symbol>
        <symbol id="icon-draw" viewBox="0 0 24 24">
            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="currentColor" />
        </symbol>
        <symbol id="icon-delete" viewBox="0 0 24 24">
            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
                fill="currentColor" />
        </symbol>
        <symbol id="icon-pages" viewBox="0 0 24 24">
            <path
                d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"
                fill="currentColor" />
        </symbol>
        <symbol id="icon-scan" viewBox="0 0 24 24">
            <path d="M12 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm1 13h-2v-6h2v6zm0-8h-2V7h2v2z"
                fill="currentColor" />
        </symbol>
    </svg>

    <div id="ocr-status">
        <div style="font-weight: 500; margin-bottom: 8px;">üîç Analysiere Stimmen...</div>
        <div id="ocr-progress" style="opacity: 0.8;">Seite 1 / ?</div>
    </div>

    <div class="toolbar" id="toolbar">
        <button class="icon-btn" onclick="location.href='/'" title="Bibliothek">
            <svg width="24" height="24">
                <use href="#icon-home" />
            </svg>
        </button>
        <div class="divider"></div>
        <!-- Part Selector Removed per user request -->
        <input type="range" id="zoom-slider" min="50" max="300" value="100" style="width: 100px;">
        <div class="divider"></div>
        <button class="icon-btn" onclick="toggleDrawingMode()" id="btn-draw" title="Zeichnen">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
            </svg>
        </button>
        <!-- OCR Button hidden as per user request to pivot to visual selection -->
        <button class="icon-btn" onclick="openOCRModal()" id="btn-ocr" title="Stimmen erkennen" style="display: none;">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M15 3V7.5L15 8H19V6H16V5H19V4H16V3H19C20.1 3 21 3.9 21 5V8C21 9.1 20.1 10 19 10H15V13H17V12H19V11H17V10H19C20.1 10 21 10.9 21 12V15C21 16.1 20.1 17 19 17H15V21H11V17H7V21H3V17C1.9 17 1 16.1 1 15V12C1 10.9 1.9 10 3 10H5V8H3C1.9 8 1 7.1 1 6V3H3V4H6V5H3V6H6V8H3V9H5V12H3V13H5V14H3V15H5V16H11V15H13V12H11V11H13V10H11V9H13V8H11V5H15V4H11V3H15M17 14H19V15H17V14M5 4H7V8H5V4M5 11H7V15H5V11M15 11H13.5L15.3 15H16.7L18.5 11H17L16 13.5L15 11Z" />
            </svg>
        </button>
        <button class="icon-btn" onclick="toggleFullscreen()" title="Vollbild">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
            </svg>
        </button>
        <button class="icon-btn" onclick="clearAnnotations()" title="L√∂schen">
            <svg width="24" height="24">
                <use href="#icon-delete" />
            </svg>
        </button>
        <button class="icon-btn" onclick="openPageSelector()" title="Seiten w√§hlen">
            <svg width="24" height="24">
                <use href="#icon-pages" />
            </svg>
        </button>
        <div class="divider"></div>
        <div class="toolbar-title" id="page-indicator">
            <span id="page_num">1</span> / <span id="page_count">1</span>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="pdf-canvas"></canvas>
        <canvas id="draw-canvas"></canvas>
        <div class="nav-overlay nav-left" onclick="handleTap('prev')" id="nav-left"></div>
        <div class="nav-overlay nav-right" onclick="handleTap('next')" id="nav-right"></div>
        <div id="feedback-left" class="touch-feedback feedback-left"></div>
        <div id="feedback-right" class="touch-feedback feedback-right"></div>
    </div>

    <!-- Page Selection Modal -->
    <div id="page-selector-modal" class="modal">
        <div class="modal-content">
            <h2 style="margin-top: 0;">Seiten ausw√§hlen</h2>
            <div style="margin-bottom: 24px; display: flex; gap: 12px;">
                <button onclick="setSelectedAll(false)" class="btn-filled"
                    style="background: var(--md-sys-color-surface-variant); color: var(--md-sys-color-on-surface-variant);">Alles
                    abw√§hlen</button>
                <button onclick="setSelectedAll(true)" class="btn-filled"
                    style="background: var(--md-sys-color-surface-variant); color: var(--md-sys-color-on-surface-variant);">Alles
                    ausw√§hlen</button>
            </div>
            <div id="page-grid"
                style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; overflow-y: auto; padding: 4px; flex: 1; min-height: 0;">
            </div>
            <div style="margin-top: 32px; display: flex; justify-content: flex-end; gap: 12px;">
                <button onclick="closePageSelector()" class="btn-filled"
                    style="background: transparent; color: var(--md-sys-color-primary);">Abbrechen</button>
                <button onclick="applyPageSelection()" class="btn-filled">Anwenden</button>
            </div>
        </div>
    </div>

    <!-- OCR Selection Overlay -->
    <div id="ocr-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; background: rgba(0,0,0,0.6);">
        <!-- Predefined Zones Container -->
        <div id="ocr-zones-container"
            style="position: absolute; top: 0; left: 0; width: 100%; height: 25%; display: flex; pointer-events: none;">
            <div class="ocr-zone" id="zone-left" onclick="selectZone('left')"
                style="flex: 1; border: 2px dashed rgba(255,255,255,0.3); pointer-events: auto; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; background: rgba(0,0,0,0.2);">
                Links (Noten)
            </div>
            <div class="ocr-zone" id="zone-center" onclick="selectZone('center')"
                style="flex: 1; border: 2px dashed rgba(255,255,255,0.3); border-left: none; pointer-events: auto; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; background: rgba(0,0,0,0.2);">
                Mitte (Noten)
            </div>
            <div class="ocr-zone" id="zone-right" onclick="selectZone('right')"
                style="flex: 1; border: 2px dashed rgba(255,255,255,0.3); border-left: none; pointer-events: auto; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; background: rgba(0,0,0,0.2);">
                Rechts (Noten)
            </div>
        </div>

        <!-- Controls -->
        <div
            style="position: absolute; top: 40%; left: 50%; transform: translateX(-50%); background: #25232a; padding: 20px; border-radius: 20px; color: #E6E1E5; pointer-events: auto; text-align: center; border: 1px solid #49454F; box-shadow: 0 4px 10px rgba(0,0,0,0.5);">
            <h3 style="margin-top: 0; margin-bottom: 16px;">Bereich w√§hlen</h3>
            <div style="margin-bottom: 20px; color: #CAC4D0; font-size: 14px;">
                Instrumente stehen meist im oberen Viertel.<br>W√§hle den passenden Bereich.
            </div>

            <div style="display: flex; gap: 12px; justify-content: center;">
                <button onclick="closeOCRMode()" class="btn-filled"
                    style="background: transparent; border: 1px solid #938F99; color: #E6E1E5; padding: 10px 20px; font-size: 14px;">Abbrechen</button>
                <button onclick="testOCR()" class="btn-filled" id="btn-test-ocr" disabled
                    style="background: #4a4458; color: #E6E1E5; padding: 10px 20px; font-size: 14px; opacity: 0.5; cursor: not-allowed;">Testen</button>
                <button onclick="scanAllPages()" class="btn-filled" id="btn-scan-ocr" disabled
                    style="background: var(--md-sys-color-primary); padding: 10px 20px; font-size: 14px; opacity: 0.5; cursor: not-allowed;">Alle
                    scannen</button>
            </div>
        </div>
    </div>

    <!-- OCR Results Modal -->
    <div id="ocr-results-modal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2100; align-items: center; justify-content: center;">
        <div
            style="background: #25232a; padding: 24px; border-radius: 16px; width: 80%; max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
            <h2 style="margin-top: 0; color: #E6E1E5;">Erkannte Stimmen</h2>
            <div id="ocr-results-list"
                style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="document.getElementById('ocr-results-modal').style.display='none'"
                    style="padding: 10px 20px; background: transparent; color: #D32F2F; border: 1px solid #D32F2F; border-radius: 20px; cursor: pointer;">Abbrechen</button>
                <button onclick="saveOCRResults()"
                    style="padding: 10px 20px; background: #D32F2F; color: white; border: none; border-radius: 20px; cursor: pointer;">Speichern</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; align-items: center; justify-content: center; flex-direction: column; color: white;">
        <div class="spinner"
            style="border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;">
        </div>
        <div style="margin-top: 20px; font-size: 18px;">Verarbeite...</div>
        <style>
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </div>

    <script>
        let isDrawingMode = false;
        const songId = {{ song.id }};
        const url = '/pdf/{{ song.file_path }}';
        const songKey = 'song_settings_{{ song.id }}';
        const padding = 20;

        let pdfDoc = null,
            pdfCanvas = document.getElementById('pdf-canvas'),
            ctx = pdfCanvas.getContext('2d'),
            drawCanvas = document.getElementById('draw-canvas'),
            drawCtx = drawCanvas.getContext('2d');

        let currentZoom = 100;
        let isDrawing = false;
        let pageRendering = false;
        let pageNumPending = null;

        let availableParts = {};
        let pageOrientations = {};

        let virtualPages = [];
        let currentVirtualIndex = 0;

        let currentPart = 'All';
        let manualPages = [];
        let cachedBboxes = {};

        // OCR State
        let ocrBox = { x: 0, y: 0, w: 0, h: 0 };

        async function loadSongData() {
            try {
                const resp = await fetch(`/song_settings/{{ song.id }}`);
                const data = await resp.json();
                if (data.settings) {
                    if (data.settings.zoom) {
                        currentZoom = data.settings.zoom;
                        document.getElementById('zoom-slider').value = currentZoom;
                    }
                    if (data.settings.manualPages) manualPages = data.settings.manualPages;
                    if (data.settings.part) currentPart = data.settings.part;
                }
                if (data.bounding_boxes) cachedBboxes = data.bounding_boxes;
                const pdfDoc_ = await pdfjsLib.getDocument(url).promise;
                pdfDoc = pdfDoc_;
                await detectPageOrientations();
                await loadParts();
                renderPage(currentVirtualIndex);
            } catch (err) {
                console.error("Error loading song data:", err);
                const saved = JSON.parse(localStorage.getItem(songKey) || '{}');
                if (saved.zoom) currentZoom = saved.zoom;
            }
        }
        loadSongData();

        async function detectPageOrientations() {
            const promises = [];
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                promises.push(pdfDoc.getPage(i).then(page => {
                    const view = page.getViewport({ scale: 1 });
                    if (view.width > view.height * 1.2) {
                        pageOrientations[i] = 'landscape';
                    } else {
                        pageOrientations[i] = 'portrait';
                    }
                }));
            }
            await Promise.all(promises);
        }

        function calculateVirtualPages() {
            let activePdfPages = [];
            if (manualPages.length > 0) activePdfPages = manualPages.sort((a, b) => a - b);
            else if (currentPart !== 'All' && availableParts[currentPart]) activePdfPages = availableParts[currentPart];
            else activePdfPages = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);

            virtualPages = [];
            activePdfPages.forEach(pNum => {
                if (pageOrientations[pNum] === 'landscape') {
                    virtualPages.push({ pdfPage: pNum, side: 'left' });
                    virtualPages.push({ pdfPage: pNum, side: 'right' });
                } else {
                    virtualPages.push({ pdfPage: pNum, side: 'full' });
                }
            });
            updatePageCounter();
        }

        async function renderPage(vIndex) {
            if (vIndex < 0 || vIndex >= virtualPages.length) return;
            currentVirtualIndex = vIndex;
            pageRendering = true;
            const vPage = virtualPages[vIndex];
            const page = await pdfDoc.getPage(vPage.pdfPage);

            const container = document.getElementById('canvas-container');
            const cw = container.clientWidth;
            const ch = container.clientHeight;
            const baseViewport = page.getViewport({ scale: 0.5 });

            let bbox;
            if (cachedBboxes[vIndex]) {
                bbox = cachedBboxes[vIndex];
            } else {
                let scanWidth = baseViewport.width;
                let scanHeight = baseViewport.height;
                let scanOffsetX = 0;
                if (vPage.side === 'left') scanWidth = baseViewport.width / 2;
                else if (vPage.side === 'right') { scanWidth = baseViewport.width / 2; scanOffsetX = - (baseViewport.width / 2); }

                const offCanvas = document.createElement('canvas');
                offCanvas.width = scanWidth; offCanvas.height = scanHeight;
                const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });
                offCtx.translate(scanOffsetX, 0);
                await page.render({ canvasContext: offCtx, viewport: baseViewport }).promise;
                bbox = getContentBoundingBox(offCtx, offCanvas.width, offCanvas.height);
                cachedBboxes[vIndex] = bbox;
                saveSettingsToServer();
                offCtx.setTransform(1, 0, 0, 1, 0, 0);
            }

            const contentW = (bbox.w / 0.5);
            const contentH = (bbox.h / 0.5);
            const scaleW = (cw - (padding * 2)) / contentW;
            const scaleH = (ch - (padding * 2)) / contentH;
            const baseScale = Math.min(scaleW, scaleH);
            const finalScale = baseScale * (currentZoom / 100);

            const visibleW = contentW * finalScale;
            const visibleH = contentH * finalScale;
            const screenOffsetX = (cw - visibleW) / 2;
            const screenOffsetY = (ch - visibleH) / 2;

            const highResViewport = page.getViewport({ scale: finalScale });
            let finalCanvasWidth = highResViewport.width;
            let finalCanvasHeight = highResViewport.height;
            let finalDrawOffsetX = 0;

            if (vPage.side === 'left') finalCanvasWidth = highResViewport.width / 2;
            else if (vPage.side === 'right') { finalCanvasWidth = highResViewport.width / 2; finalDrawOffsetX = - (highResViewport.width / 2); }

            const canvasLeft = screenOffsetX - ((bbox.x / 0.5) * finalScale);
            const canvasTop = screenOffsetY - ((bbox.y / 0.5) * finalScale);

            pdfCanvas.width = finalCanvasWidth; pdfCanvas.height = finalCanvasHeight;
            drawCanvas.width = finalCanvasWidth; drawCanvas.height = finalCanvasHeight;

            ctx.save();
            ctx.translate(finalDrawOffsetX, 0);
            await page.render({ canvasContext: ctx, viewport: highResViewport }).promise;
            ctx.restore();

            pdfCanvas.style.left = canvasLeft + 'px'; pdfCanvas.style.top = canvasTop + 'px';
            drawCanvas.style.left = canvasLeft + 'px'; drawCanvas.style.top = canvasTop + 'px';

            loadAnnotations(vPage.pdfPage, vPage.side);
            pageRendering = false;
            updatePageCounter();

            if (pageNumPending !== null) { renderPage(pageNumPending); pageNumPending = null; }
        }

        function getContentBoundingBox(ctx, w, h) {
            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            let minX = w, minY = h, maxX = 0, maxY = 0;
            const threshold = 250;
            for (let y = 0; y < h; y += 5) {
                for (let x = 0; x < w; x += 5) {
                    const i = (y * w + x) * 4;
                    if (data[i] < threshold || data[i + 1] < threshold || data[i + 2] < threshold) {
                        if (x < minX) minX = x; if (x > maxX) maxX = x;
                        if (y < minY) minY = y; if (y > maxY) maxY = y;
                    }
                }
            }
            if (maxX < minX) return { x: 0, y: 0, w: w, h: h };
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        }

        function queueRenderPage(vIndex) {
            if (pageRendering) pageNumPending = vIndex; else renderPage(vIndex);
        }
        function updatePageCounter() {
            document.getElementById('page_num').textContent = currentVirtualIndex + 1;
            document.getElementById('page_count').textContent = virtualPages.length;
        }
        function prevPage() { if (currentVirtualIndex > 0) queueRenderPage(currentVirtualIndex - 1); }
        function nextPage() { if (currentVirtualIndex < virtualPages.length - 1) queueRenderPage(currentVirtualIndex + 1); }

        function loadParts() {
            return fetch('/analyze_parts/{{ song.id }}').then(r => r.json()).then(data => {
                availableParts = data;
                availableParts = data;
                // Part select dropdown removed
                if (manualPages.length === 0 && currentPart !== 'All' && availableParts[currentPart]) {
                    // Logic to handle existing part selection if any (legacy), or just default to All
                }
                calculateVirtualPages();
            });
        }

        function changePart() {
            // Function functionality reduced as UI element is gone. 
            // Kept for compatibility if called from elsewhere, but effectively does nothing 
            // or just resets to default if needed.
            calculateVirtualPages(); currentVirtualIndex = 0; renderPage(0);
        }

        function openPageSelector() {
            const modal = document.getElementById('page-selector-modal');
            const grid = document.getElementById('page-grid');
            grid.innerHTML = '';
            grid.style.display = 'block'; /* List mode, not grid */
            grid.style.width = '100%';
            grid.style.margin = '0 auto';
            grid.style.flex = '1'; /* Take remaining vertical space for scrolling */
            grid.style.minHeight = '0'; /* Critical for proper flex scrolling */
            grid.style.overflowY = 'auto'; /* Ensure scrollable */
            grid.style.webkitOverflowScrolling = 'touch';
            grid.style.touchAction = 'pan-y'; /* Explicitly allow vertical panning */

            // Custom Scrollbar for better touch usability
            const style = document.createElement('style');
            style.innerHTML = `
                #page-grid::-webkit-scrollbar { width: 30px; }
                #page-grid::-webkit-scrollbar-track { background: #333; border-radius: 15px; }
                #page-grid::-webkit-scrollbar-thumb { background: #666; border-radius: 15px; border: 4px solid #333; }
                #page-grid::-webkit-scrollbar-thumb:hover { background: #888; }
            `;
            document.head.appendChild(style);

            // Default: Select nothing (empty list) unless user has already selected manual pages
            let currentlySelected = manualPages.length > 0 ? manualPages : [];
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const div = document.createElement('div');
                div.className = 'page-grid-item' + (currentlySelected.includes(i) ? ' selected' : '');
                div.dataset.pageNum = i;

                // Image
                const img = document.createElement('img');
                img.src = `/thumbnail/${songId}/${i}`;
                img.className = 'page-thumb';
                img.loading = 'lazy';
                img.setAttribute('draggable', 'false'); // Prevent native drag
                img.oncontextmenu = function (e) { e.preventDefault(); return false; }; // Prevent long-press menu
                div.appendChild(img);

                // Badge
                const badge = document.createElement('div');
                badge.className = 'page-number-badge';
                badge.textContent = i;
                div.appendChild(badge);

                if (pageOrientations[i] === 'landscape') {
                    const ls = document.createElement('small');
                    ls.style.fontSize = '10px'; ls.style.opacity = '0.7'; ls.textContent = 'Landscape';
                    div.appendChild(ls);
                }

                div.dataset.selected = currentlySelected.includes(i);
                // Handle Click vs Drag for touch devices
                let isDrag = false;
                let startY = 0;

                div.addEventListener('touchstart', function (e) {
                    isDrag = false;
                    startY = e.touches[0].clientY;
                }, { passive: true });

                div.addEventListener('touchmove', function (e) {
                    if (Math.abs(e.touches[0].clientY - startY) > 10) {
                        isDrag = true;
                    }
                }, { passive: true });

                div.onclick = function (e) {
                    if (isDrag) return; // Ignore click if it was a scroll/drag

                    const isSel = div.dataset.selected === 'true';
                    div.dataset.selected = !isSel;
                    if (!isSel) div.classList.add('selected'); else div.classList.remove('selected');
                };
                grid.appendChild(div);
            }
            modal.style.display = 'flex';
        }
        function setSelectedAll(selected) {
            document.getElementById('page-grid').childNodes.forEach(div => {
                div.dataset.selected = selected;
                if (selected) div.classList.add('selected'); else div.classList.remove('selected');
            });
        }
        function closePageSelector() { document.getElementById('page-selector-modal').style.display = 'none'; }

        function applyPageSelection() {
            const grid = document.getElementById('page-grid');
            const selected = [];
            grid.childNodes.forEach(node => { if (node.dataset.selected === 'true') selected.push(parseInt(node.dataset.pageNum)); });
            manualPages = selected.sort((a, b) => a - b);
            saveSettingsToServer();
            manualPages = selected.sort((a, b) => a - b);
            saveSettingsToServer();
            // document.getElementById('part-select').value = 'Manual'; // Removed
            calculateVirtualPages(); currentVirtualIndex = 0; renderPage(0); closePageSelector();
        }

        document.getElementById('zoom-slider').addEventListener('input', (e) => {
            currentZoom = e.target.value; saveSettingsToServer(); renderPage(currentVirtualIndex);
        });

        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('btn-draw');
            const navLeft = document.getElementById('nav-left');
            const navRight = document.getElementById('nav-right');
            if (isDrawingMode) {
                if (btn) btn.classList.add('active');
                drawCanvas.style.pointerEvents = 'auto';
                if (navLeft) navLeft.style.display = 'none';
                if (navRight) navRight.style.display = 'none';
            } else {
                if (btn) btn.classList.remove('active');
                drawCanvas.style.pointerEvents = 'none';
                if (navLeft) navLeft.style.display = 'block';
                if (navRight) navRight.style.display = 'block';
                const vPage = virtualPages[currentVirtualIndex];
                saveAnnotations(vPage.pdfPage, vPage.side);
            }
        }

        function loadAnnotations(page, side) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            const storageKey = songKey + '_page_' + page + '_' + side;
            const data = localStorage.getItem(storageKey);
            if (data) {
                const img = new Image();
                img.onload = function () { drawCtx.drawImage(img, 0, 0); };
                img.src = data;
            }
        }
        function saveAnnotations(page, side) {
            const data = drawCanvas.toDataURL();
            const storageKey = songKey + '_page_' + page + '_' + side;
            localStorage.setItem(storageKey, data);
        }
        function clearAnnotations() {
            if (confirm("Alle Zeichnungen auf dieser Seite l√∂schen?")) {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                const vPage = virtualPages[currentVirtualIndex];
                const storageKey = songKey + '_page_' + vPage.pdfPage + '_' + vPage.side;
                localStorage.removeItem(storageKey);
            }
        }

        // Drawing Events
        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseout', stopDrawing);
        drawCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); const touch = e.touches[0];
            drawCanvas.dispatchEvent(new MouseEvent("mousedown", { clientX: touch.clientX, clientY: touch.clientY }));
        });
        drawCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); const touch = e.touches[0];
            drawCanvas.dispatchEvent(new MouseEvent("mousemove", { clientX: touch.clientX, clientY: touch.clientY }));
        });
        drawCanvas.addEventListener('touchend', (e) => { drawCanvas.dispatchEvent(new MouseEvent("mouseup", {})); });

        function startDrawing(e) { if (isDrawingMode) { isDrawing = true; draw(e); } }
        function draw(e) {
            if (!isDrawing || !isDrawingMode) return;
            const rect = drawCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left); const y = (e.clientY - rect.top);
            drawCtx.lineWidth = 3; drawCtx.lineCap = 'round'; drawCtx.strokeStyle = 'red';
            drawCtx.lineTo(x, y); drawCtx.stroke(); drawCtx.beginPath(); drawCtx.moveTo(x, y);
        }
        function stopDrawing() { if (!isDrawing) return; isDrawing = false; drawCtx.beginPath(); const vPage = virtualPages[currentVirtualIndex]; saveAnnotations(vPage.pdfPage, vPage.side); }

        function handleTap(action) {
            if (isDrawingMode) return;
            if (action === 'prev') { triggerFeedback('left'); prevPage(); }
            else if (action === 'next') { triggerFeedback('right'); nextPage(); }
        }
        function triggerFeedback(side) {
            const el = document.getElementById('feedback-' + side);
            el.classList.add('active'); setTimeout(() => el.classList.remove('active'), 200);
        }

        // --- OCR Logic ---
        function openOCRModal() {
            document.getElementById('ocr-overlay').style.display = 'block';
            selectZone(null); // Reset selection
        }
        function closeOCRMode() {
            document.getElementById('ocr-overlay').style.display = 'none';
        }

        function selectZone(zone) {
            // UI Update
            document.querySelectorAll('.ocr-zone').forEach(el => {
                el.style.background = 'rgba(0,0,0,0.2)';
                el.style.border = '2px dashed rgba(255,255,255,0.3)';
                if (zone && el.id === 'zone-' + zone) {
                    el.style.background = 'rgba(211, 47, 47, 0.4)';
                    el.style.border = '2px solid #D32F2F';
                }
            });

            const btnTest = document.getElementById('btn-test-ocr');
            const btnScan = document.getElementById('btn-scan-ocr');

            if (!zone) {
                ocrBox = { w: 0 };
                if (btnTest) { btnTest.disabled = true; btnTest.style.opacity = 0.5; btnTest.style.cursor = 'not-allowed'; }
                if (btnScan) { btnScan.disabled = true; btnScan.style.opacity = 0.5; btnScan.style.cursor = 'not-allowed'; }
                return;
            }

            if (btnTest) { btnTest.disabled = false; btnTest.style.opacity = 1; btnTest.style.cursor = 'pointer'; }
            if (btnScan) { btnScan.disabled = false; btnScan.style.opacity = 1; btnScan.style.cursor = 'pointer'; }

            const h = 25.0;
            const w = 33.33;
            let x = 0;
            if (zone === 'center') x = 33.33;
            if (zone === 'right') x = 66.66;

            ocrBox = { x: x, y: 0, w: w, h: h };
        }

        function testOCR() {
            if (ocrBox.w === 0) { alert("Bitte erst einen Bereich w√§hlen!"); return; }
            fetch('/scan_part_region', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    song_id: songId,
                    page: virtualPages[currentVirtualIndex].pdfPage,
                    box: ocrBox
                })
            }).then(r => r.json()).then(data => {
                if (data.status === 'success') alert("Erkannt: " + data.text);
                else alert("Fehler: " + data.message);
            });
        }

        function scanAllPages() {
            if (ocrBox.w === 0) { alert("Bitte erst einen Bereich w√§hlen!"); return; }
            document.getElementById('loading-overlay').style.display = 'flex';
            fetch('/scan_all_pages_region', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ song_id: songId, box: ocrBox })
            }).then(r => r.json()).then(data => {
                document.getElementById('loading-overlay').style.display = 'none';
                if (data.status === 'success') showOCRResults(data.results);
                else alert("Fehler: " + data.message);
            });
        }

        function showOCRResults(results) {
            const listDiv = document.getElementById('ocr-results-list');
            listDiv.innerHTML = '';
            for (const [page, text] of Object.entries(results)) {
                const row = document.createElement('div');
                row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '10px';
                row.innerHTML = `<span style="width: 60px;">Seite ${page}:</span><input type="text" value="${text}" class="input-pill" style="flex: 1;">`;
                listDiv.appendChild(row);
            }
            document.getElementById('ocr-results-modal').style.display = 'flex';
        }

        function saveOCRResults() {
            const inputs = document.querySelectorAll('#ocr-results-list input');
            const mapping = {};
            inputs.forEach((input, index) => {
                const text = input.value.trim();
                if (text) {
                    if (!mapping[text]) mapping[text] = [];
                    mapping[text].push(index + 1);
                }
            });
            fetch('/save_part_mapping', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ song_id: songId, parts: mapping })
            }).then(r => r.json()).then(() => {
                document.getElementById('ocr-results-modal').style.display = 'none';
                closeOCRMode();
                alert("Stimmen gespeichert!");
                location.reload();
            });
        }

        function saveSettingsToServer() {
            const data = {
                settings: { zoom: currentZoom, manualPages: manualPages, part: currentPart },
                bounding_boxes: cachedBboxes
            };
            fetch(`/song_settings/{{ song.id }}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            localStorage.setItem(songKey, JSON.stringify(data.settings));
        }

        document.addEventListener('keydown', (e) => {
            if (isDrawingMode) return;
            if (['ArrowRight', 'Space', 'Enter', 'PageDown'].includes(e.key) || e.code == 'Space') { triggerFeedback('right'); nextPage(); }
            else if (['ArrowLeft', 'Backspace', 'PageUp'].includes(e.key)) { triggerFeedback('left'); prevPage(); }
        });
        document.getElementById('canvas-container').addEventListener('click', (e) => {
            if (isDrawingMode) return;
            if (e.target.id === 'canvas-container' || e.target.id === 'pdf-canvas') {
                document.getElementById('toolbar').classList.toggle('visible');
            }
        });
    </script>
</body>

</html>